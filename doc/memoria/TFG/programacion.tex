%chapter introduce un nuevo capítulo
\chapter{Programación TODO}

En este capítulo se presenta el desarrollo de todo el software que ha sido requerido preparar para la puesta en marcha del robot.

\section{Configuración de la BeagleBone Black TODO}

De fabrica... TODO

\subsection{Sistema operativo}

El controlador principal, la BeagleBone Black, trae de fábrica una instalación de una distribución Ångström basada en Linux. El sistema operativo incluye: entorno gráfico, escritorio, OpenCV 2.2 y otros programas como navegadores o reproductores de archivos multimedia. Esto se debe a que la BeagleBone Black no es una placa que de fábrica esté pensada para su uso en robots, sino que constituye un ordenador completo que puede adquirir la función de centro multimedia, equipo de ofimática o incluso servidor de una red.

\medskip La distribución Ångström no es una de las más populares entre los sistemas operativos basados en Linux, no cuenta con una comunidad de usuarios tan amplia como Debian o Fedora. Por ello, las actualizaciones no suelen ser muy frecuentes y, en muchos casos, el sistema presenta errores de funcionamiento a la hora de realizar tareas básicas, como la instalación de nuevo software.

\medskip Por esta razones se ha decidido instalar un nuevo sistema operativo. Se pretende conseguir una distribución de Linux que solo tenga lo mínimo necesario que requiere el robot para su funcionamiento. Con este objetivo, se instala en la BeagleBone Black una distribución Debian.

\subsection{Instalación de librerías TODO}

Para la realización del proyecto, se ha requerido instalar Git, CMake, Video4Linux2 y las librerías de OpenCV 2.4.8 y ZBar 0.1.

\medskip Antes de comenzar con la instalación de software, es recomendable realizar una actualización del sistema ejecutando los siguientes comandos:

\begin{verbatim}
sudo apt-get update
sudo apt-get upgrade
\end{verbatim}

\bigskip  Lo primero que instalaremos será Git, ya que lo necesitaremos para instalar algunas librarías posteriormente. Git se instala ejecutando el siguiente comando: 
\begin{verbatim}
sudo apt-get install git-core
\end{verbatim}

\bigskip Para instalar CMake lo haremos de la siguiente forma:

\begin{verbatim}
sudo apt-get install cmake
sudo apt-get install cmake-curses-gui
\end{verbatim}

\bigskip Para el control y configuración de la webcam se necesitará el driver Video4Linux. Se instalará como se muestra a continuación:

\begin{verbatim}
sudo apt-get install v4l-utils
\end{verbatim}


\bigskip  Una vez hecho esto, se pasará a instalar las librerías que se utilizarán en el código del robot. La forma mas sencilla de instalar Zbar será hacerlo desde los repositorios de Debian. De este modo, ejecutaremos los siguientes comandos:
\begin{verbatim}
sudo apt-get install libzbar0
sudo apt-get install libzbar-dev
\end{verbatim}

\bigskip  Por último, instalaremos OpenCV. Se comenzará por descargar todas las librarías que requiere OpenCV. Se instalarán una a una de la siguiente forma:
\begin{verbatim}
sudo apt-get install build-essential 
sudo apt-get install libgtk2.0-dev 
sudo apt-get install pkg-config 
sudo apt-get install python-dev 
sudo apt-get install python-numpy 
sudo apt-get install libavcodec-dev 
sudo apt-get install libavformat-dev 
sudo apt-get install libswscale-dev
\end{verbatim}

Hecho esto, se procederá a descargar la última versión estable del código, que en este momento es la 2.4.9.

\begin{verbatim}
wget http://downloads.sourceforge.net/project/opencvlibrary/opencv-unix/2.4.9/opencv-2.4.9.zip
\end{verbatim}

\bigskip Y posteriormente se instalará de este modo:

\begin{verbatim}
unzip opencv-2.4.9.zip
cd opencv-2.4.9
mkdir build
cd build
cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..
make
sudo make install
\end{verbatim}

\subsection{Configuración de la cámara}

A continuación se configurará la webcam en la beaglebone. Para esto se conectará por USB la Microsoft Lifecam a la BeagleBone Black tal y como puede observarse en la figura \ref{robotbbbcam}. A partir de aquí, se iniciará sesión en la BeagleBone Black y se procederá a configurar la cámara.

\medskip Lo primero que se hará será comprobar que la cámara se ha reconocido correctamente. Para ello ejecutaremos el comando:

\begin{verbatim}
lsusb
\end{verbatim}

\bigskip Y deberá proporcionarnos una salida parecida a la que puede observarse en la figura \ref{lsusbbbb}. La salida indica que la webcam está conectada en el bus 001

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/lsusbbbb}   
\caption{Salida del comando lsusb}
\label{lsusbbbb}
\end{figure}

\medskip Para cerciorarno de que la cámara se ha reconocido correctamente podemos buscarla en el directorio /dev. En la siguiente imagen (figura \ref{lsdev}) se observa el archivo /dev/video0, que está vinculado a la webcam.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/lsdev}   
\caption{Comprobación de conexión para la webcam}
\label{lsdev}
\end{figure}

A continuación nos ayudaremos de las utilidades de Video4Linux (una interfaz para la programación de aplicaciones con captura de imágenes para Linux) para la webcam. OpenCV se apoya en Video4Linux, por tanto, lo primero que se hará será comprobar que la cámara es compatible con Video4Linux. Para ello, se ejecutará el siguiente comando:

\begin{verbatim}
v4l2-ctl --list-devices
\end{verbatim}

\bigskip Tras ejecutarlo se deberá observar una salida similar a la de la figura \ref{v4llist}

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/v4llist}   
\caption{Comprobación de compatibilidad para la webcam}
\label{v4llist}
\end{figure}

Ésto nos confirma que la cámara funciona correctamente. Para proseguir con la configuración vamos a ejecutar el comando siguiente:

\begin{verbatim}
v4l2-ctl --all
\end{verbatim}

\bigskip  En la figura \ref{v4lall} podemos observar la salida del comando. En ella se pueden observar diferentes parámetros como el formato de video, la resolución o los fotogramas por segundo.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/v4lall}   
\caption{Parámetros leídos de la cámara}
\label{v4lall}
\end{figure}

\medskip Por último, se bajará la resolución de la cámara a un valor que nos permita tratar las imágenes con mayor rapidez cuando se programen algoritmos de visión con OpenCV desde la BeagleBone Black. Se ha elegido una resolución de 320x240, mas adelante se ajustará este valor empíricamente en función del rendimiento del robot. Para ello ejecutamos este comando de configuración:

\begin{verbatim}
v4l2-ctl --set-fmt-video=width=320,heigth=240
\end{verbatim}

\bigskip  Tras estos pasos la cámara ya está preparada y lista para usarse.

%vdeo capture aplication progamin interface for linux

\subsection{Programación de scripts de configuración TODO}



\section{Sistema de locomoción TODO}

Antes de comenzar con esta sección, es importante señalar algunos detalles importantes. Si bien es cierto, el control del robot girará en torno a un algoritmo de visión, su funcionamiento de apoyará en un control de locomoción robusto que permita al robot realizar desplazamientos seguros sobre el terreno. Por tanto, dado que se trata de un robot bípedo, la programación de movimientos no es un tema trivial como lo podría ser en un robot con ruedas.

Para conseguir que Raider pueda moverse con soltura se han seguido varios pasos, cada cual de un nivel superior al anterior.

\subsection{Movimiento del servo PWM}
% aqui no explicar el principio de funcionamiento, solo la parte de programacion
% o sea, de Servo.write para arriba

El control del servo PWM de Raider, situado en su cabeza, se realiza con la biblioteca Servo.h orginalmente desarrolladas para Arduino y que posteriormente ha sido portada para su utilización en OpenCM. Dado el cometido de este servo, no será necesario realizar un control de su velocidad, por lo que un simple control de su posición será suficiente.

La biblioteca Servo.h nos permite controlar el movimiento de un servo a partir de un valor de posición, y se encarga de producir la señal PWM correspondiente. Aunque los métodos utilizados pueden encontrarse en la documentación de Arduino ( TODO ), a continuación introduzco una breve explicación de los que han sido utilizados en este proyecto:

\subsubsection{Servo::attach(uint8 pin)}

Con esta función configuramos un pin de la OpenCM para que actúe como emisora de señales PWM. A partir de esta inicialización ya puede moverse el servo.

\subsubsection{Servo::writeMicroseconds(uint16 pulseWidth)}

Para mover el servo se utiliza la función writeMicroseconds, cuyo parámetro define la amplitud  del pulso de la onda PWM. Si bien es cierto, existe otra función paralela llamada write(int angle) que directamente utiliza como parámetro la posición en grados, se ha utilizado writeMicroseconds por su mayor precisión. Acepta valores de entre 1000 y 2000 microsegundos, pero para mantener un formato constante con el resto de articulaciones, se ha realizado una conversión matemática a un rango de 0 a 1023.

\subsection{Movimiento de los actuadores Dynamixel}

Para comunicarse con los actuadores Dynamixel (de los que hablamos en TODO ) debemos utilizar su protocolo particular. Los servos son controlados mediante el envio de paquetes de datos binarios. Existen dos tipos de paquetes en el protocolo: Los paquetes de instrucciones, que son los que envia el controlador a los servos; y los paquetes de estado, que son los los servos envían al controlador.

\medskip 
Cada servo tiene una ID, o dicho de otra forma, un número de identidad propio e irrepetible que identifica a un servo particular dentro del bus. La comunicación en el bus se realiza mediante el intercambio de paquetes de instrucciones y estados con una ID concreta.
Por esta razón, en un mismo bus no deben existir servos con la misma ID, ya que provocarán colisiones entre los paquetes e impedirán el correcto funcionamiento del sistema. Sin embargo, estas ID son fácilmente reprogramables y pueden modificarse realizando una escritura sobre el registro 3 (0X03).

\medskip 
El protocolo de comunicación utilizado es una comunicación serie asíncrona de 8 bits, con 1 bit de Stop y sin paridad. La conexión, de tipo Half Duplex, no permite la transmision y recepción de paquetes de forma simultanea. Esto la convierte en una conexión bastante típica en los sistema que utilizan un solo bus de comunicación. Como en el mismo bus existe mas de un dispositivo, todos deben permanecer en modo de escucha salvo el que esté transmitiendo en ese instante. El controlador principal, la placa OpenCM 9.04, asigna la dirección del bus en modo escucha, y solo cambia la dirección del bus a modo de envio mientras manda un paquete. (TODO revisar) Los Dynamixel AX-12A poseen una tabla de registros (tabla TODO ) sobre la cual podemos modificar varios parámetros referente a su estado y su funcionamiento. La tabla de registros puede consultarse en TODO .

\medskip 
Para realizar una rotación simple en un servomotor, sería suficiente con escribir en el registro 32 (Goal Position) un valor comprendido entre 0 y 1023, y el servo se situará inmediatamente en esa posición. Sin embargo, existen otros parámetros interesantes en el mapa de registros que conviene controlar, como la posición instantanea, la velocidad de giro, el consumo eléctrico o incluso la temperatura del dispositivo.

\medskip 
Para mover los 19 AX-12A de Raider se utilizan los parámetros de posición objetivo (Goal Position) y velocidad de giro (Moving Speed) de forma combinada. Dado que está programación se ha realizado desde la OpenCM 9.04 se ha utilizado la biblioteca Dynamixel.h, que funciona como una macro para leer y escribir en los registros de forma sencilla y eficiente. Dentro de la biblioteca utilizaremos la función writeWord con la siguiente sintaxis:

% TODO arreglar codigos

\begin{verbatim}
Dxl.writeWord(
	Dynamixel_Motor_Number,	
	Address_Number,
	Address_Data
);
\end{verbatim}

A modo de ejemplo, para asignar una velocidad de $3.5rad/s$ al servo con la ID 5, primero calcularíamos el valor correspondiente para una resolución de 10 bits. Según el manual de los servos Dynamixel ( TODO citar) AX-12A, la velocidad máxima de estos servomotores es de $114rpm$. Por tanto, se realizaría la siguiente conversión:

\[ 3.5 \cdot \frac{rad}{s} \cdot \frac{60 s}{2 \pi rad} \cdot rpm \cdot \frac{1024}{114 rpm}= 300.216 \simeq 300 \]

\medskip
Dentro del código, utilizaremos la función writeWord para asignar este valor en el registro 32 (Moving Speed):

% TODO arreglar codigos
\begin{verbatim}
Dxl.writeWord(5,32,300);
\end{verbatim} 

Seguidamente, asignaríamos al servo una posición final siguiendo el criterio de la figura \ref{goalposition}

\begin{figure}[h]
\centering
\includegraphics[width=0.55\textwidth]{figuras/goalposition}   
\caption{Amplitud de giro de un AX-12A}
\label{goalposition}
\end{figure}

Continuando con el ejemplo, calcularemos el valor que debemos darle al registro para mover el servo a una posición de $120º$, teniendo en cuenta que las especificaciones nos indican una amplitud de giro total de 300º reales con una resolución de 10 bits. De esta forma, haríamos la siguiente conversión:

\[ 120º \cdot \frac{1024}{300º}= 409.6 \simeq 410 \]

\medskip
En nuestro programa escribiríamos en el registro 30 (Goal Position) de la siguiente forma:

% TODO arreglar codigos
\begin{verbatim}
Dxl.writeWord(5,30,410);
\end{verbatim} 

Como resumen, con estos pasos hemos conseguido mover el servo con la ID 5 (Que corresponde al codo del brazo izquierdo de Raider), a una posición de $120º$ con una velocidad de $3.5 rad/s$

\subsection{Movimiento sincronizado de las articulaciones}

En el apartado anterior se ha mostrado cómo se realiza el movimiento de un servo, sin embargo, para mover el cuerpo del robot necesitaremos mover todos al mismo tiempo de una forma sincronizada. Si en el apartado anterior utilizabamos la posición objetivo y la velocidad de movimiento como parámetros, en este punto, por comodidad a la hora de programar, utilizaremos como parámetros la posición objetivo de los 20 servos, su posición actual y el tiempo total durante el que se realizará su movimiento entre ambos puntos.

\medskip
Este es quizás uno de los apartados mas críticos a la hora de diseñar las funciones que moverán el robot. Se pretende programar una biblioteca que permita mover 20 servos simultaneamente, con velocidades diferentes condicionadas por un tiempo de ejecución común. De esta forma, los servos cuya posición objetivo sea lejana a su posición actual se moverán con una velocidad mayor que la de los servos cuya posición objetivo sea cercana a su posición actual.

\medskip
Las funciones pueden encontrarse en la biblioteca raider TODO motion.h

\subsubsection{class Robot} 

La clase Robot abarca todas las funciones relativas al movimiento de Raider (aunque por el momento en esta sección solo se presenta algunas de ellas), y abstrae su controlador principal, la BeagleBone Black de la parte de locomoción. Dentro de la clase, encontramos tres variables miembros importantes:

\begin{itemize}
\item \textbf{int currentPosition[20]}.

currentPosition es un array de 20 posiciones destinado a almacenar los valores de las posición actual de las 20 articulaciones del robot con valores comprendidos entre 0 y 1023. El primer valor es el servo AX-12A, el segundo es el servo PWM de la cabeza y a partir de ese punto están el resto de AX-12A ordenados según su ID, del número 1 al 18.

\item \textbf{int targetPostion[20]}.

targetPosition sigue la misma estructura de currentPosition, con la diferencia de que en este caso los valores guardados en el array corresponderán con la posición objetivo o posición final de las articulaciones.

\item \textbf{int TRIM[20]}.

Por último, TRIM es un array de trims. Un trims es una variable de ajuste para calibrar la posición de los servos. Tanto los servos Dynamixel como los servos PWM suelen tener un pequeño error en su posición cero. Los trimmers constituyen un offset aplicado individualmente a cada servo en absolutamente todos los movimientos que se realizarán durante el programa. Las holguras y otros factores pueden provocar el desajuste de esto valores, por lo que es necesario volver a calibrarlo cada cierto tiempo. Una mala calibración de los trims puede radicar en problemas de asimetrías en movimientos, y por tanto, resultados inesperados.

\end{itemize}

\subsubsection{Robot::Robot()}

El constructor de la clase Robot tiene como función la apertura del bus de control para los servos AX-12A, la configuración del servo PWM y la asignación de trims en el array de trims.
 


\subsubsection{void Robot::setTargetPosition(int,int,... int)}

setTargetPosition accede directamente al miembro privado targetPosition[20] para asignarle nuevos valores.

\subsubsection{void Robot::setTargetOffset(int,int,... int)}

setTargetOffset varía los valores del miembro privado targetPosition[20] para sumarles un valor. La función permite variar una posición con un giro determinado sin necesidad de conocer la posición actual de la articulación.


\subsubsection{void Robot::updateCurrentPosition()}

Esta función tiene un funcionamiento sencillo, se ocupa de volcar los datos de la posición objetivo en la posición actual. Es la forma que tiene el robot de actualizar su posición actual tras un movimiento. 

\subsubsection{void Robot::move(float)} 

La función move es la mas importante de todas, ya que es la función que se encarga de mover las articulaciones. A esta función se le pasa un valor de tiempo expresado en segundos, y tal y como se comentó al principio de este apartado, será el tiempo en el que los servos pasarán de la posición actual (currentPosition[20]) a la posición final (targetPosition[20]).

\medskip
Para ello, la función calcula la amplitud del movimiento y asigna una velocidad independiente para ese servo. Gracias a esto, todos los servos empiezan y terminan de moverse al mismo tiempo y permiten un control mas sencillo de las inercias entre movimientos consecutivos.

\subsection{Funciones de movimientos combinados TODo } 

Llegado este punto hemos abordado como mover un servo y como mover los 20 servos de forma coordinada. En este apartado se presentan algunas funciones intermedias entre lo comentado y movimientos de alto nivel como puede ser el desplazamiento bípedo.

\medskip
Para facilitar la programación de movimientos mas complejos se han programado una seríe de utilidades que permiten mover los servos en pequeños grupos que desempeñan una funcion común. Estas funciones modifican los valores del array de posiciones finales, targetPosition[20], lo que quiere decir que para efectuar el movimiento será necesario realizar una llamada a la funcion move(float). Por tanto, es posible la utilización de varias funciones en un mismo movimiento, dando la posibilidad de sumar sus modificaciones y superponer su utilidades. 

\subsubsection{void movHead(int)}

movHead es una función que permite mover el servo PWM de la cabeza del robot. Sirve para mover la cámara independientemente de la posición instantanea del robot.


% Dibujos y otras movidas
\subsubsection{void movVertical(int,int) TODO}
\subsubsection{void movLateral(int,int) TODO}
\subsubsection{void movFrontal(int,int) TODO}

\subsection{Creación de movimientos completos TODO}

Encontrándonos en este punto, la programación de desplazamientos, giros y otros movimientos complejos, se ha realizado mediante la combinación de las funciones anteriormente descritas (TODO aquí hay que pensar si meter ilustraciones o como)

\subsection{Controlador de movimientos TODO}


\section{Comunicación serie}

En la sección anterior hemos completado la programación de movimientos sobre la placa OpenCM, sin embargo, el control principal del robot se realiza desde la BeagleBone. En este apartado se comunicará la BeagleBone con la OpenCM de forma que adopten una configuración de maestro y esclavo. La estrategia consistirá en el envío de comandos sencillos desde la BeagleBone a la OpenCM. Cada comando servirá de identificador para un movimiento completo. Se ha seguido el criterio que típicamente es usado en los videojuegos de PC (figura ), utilizando las teclas W, A, S, y D para los desplazamientos del robot e identificando el resto de movimientos por su letra inicial. A continuación, en el cuadro \ref{movimientos} se presenta una tabla con los movimientos programados y su comando asignado.

\begin{table}[H]
\centering
\begin{tabular}{p{1.5cm} p{2cm} p{8cm}}
\hline
Comando & Función & Descripción \\
\hline \hline
\centering W & walk(3) & Caminar 3 pasos cortos\\ \hline
\centering A & turnL() & Rotación a la izquierda  \\ \hline
\centering D & turnR() & Rotación a la derecha  \\ \hline
\centering S & run(3) & Caminar 3 pasos largos y rápidos  \\ \hline
\centering Q & stepL() & Paso lateral a la izquierda  \\ \hline
\centering E & stepR() & Paso lateral a la derecha  \\ \hline
\centering K & kick() & Patada (para golpear una pelota)  \\ \hline
\centering Y & yes() & Movimiento intermitente de la cabeza  \\ \hline
\centering G & getUp() & Levantamiento desde una caída frontal  \\ \hline
\centering R & roll() & Rodar, se utiliza cuando el robot cae de espaldas  \\ \hline
\centering H & hello() & Saludo  \\ \hline


\end{tabular}
\caption{Movimientos programados}
\label{movimientos}
\end{table}


En primer lugar, se debe realizar una conexión entre las dos placas. Se ha elegido una comunicación tipo serie por su fácil puesta en marcha y fiabilidad. La BeagleBone posee hasta 5 puertos serie. En la figura \ref{serial} puede observarse la configuración de pines para cada uno de los puertos.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figuras/serial}   
\caption{Esquema de puertos serie en una BeagleBone Black}
\label{serial}
\end{figure}

Por otro lado, la OpenCM posee 3 puertos serie, de los cuales uno de ellos está reservado para el control del bus Dynamixel. En el esquema de la figura \ref{serialcm} se presenta la configuración de puertos serie de la OpenCM.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{figuras/serialcm}   
\caption{Esquema de puertos serie en una OpenCM 9.04}
\label{Serialcm}
\end{figure}

Adicionalmente, se ha incluido la posibilidad de utilizar un control auxiliar por Bluetooth desde un dispositivo externo. Para ello se ha conectado un modulo Bluetooth directamente a la OpenCM. La función de esta otra vía de control no es otra que la realización de pruebas experiemtnales controladas, ya que nos permite modificar el comportamiento del robot en los momentos en los que sea necesario. Por supuesto, de cara a su funcionamiento autónomo, el módulo Bluetooth se inutilizará. Sin embargo, será necesario dejar preparada su conexión y programación.

\subsection{Comunicación serie en OpenCM  TODO}

Para la programación de la comunicación serie en la placa OpenCM se ha utilizado la biblioteca HardwareSerial.h, contenida en CM9 IDE. La documentación de la biblioteca está disponible en (  TODO), sin embargo, a continuación se listan las funciones que se han utilizado junto a una breve explicación de su funcionamiento.
 ( TODO )
% todo 
\subsubsection{void HardwareSerial::begin(unsigned int baud) TODO}
\subsubsection{unsigned int HardwareSerial::available() TODO}
\subsubsection{unsigned char HardwareSerial::read() TODO}
\subsubsection{void HardwareSerial::flush() TODO}
 
\subsection{Comunicación serie en BeagleBone TODO}

\subsection{Comunicación con módulo Bluetooth TODO}

\section{Programación de sensores TODO} 
\subsection{Infrarrojos TODO}

Lecturas analogicas
 
\subsection{IMU TODO}

Con todo el tostonazo de I2C

\subsection{Brújula TODO} 



\section{Algoritmos de visión TODO} 
\subsection{Análisis de trayectorias en navegación TODO} 
\subsection{Búsqueda de lineas TODO}
\subsection{Lectura de códigos QR TODO} 
 






















